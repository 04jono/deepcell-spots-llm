[{"code": "\ndef threshold_image(image, clip=False):\n    \"\"\"Apply a simple thresholding technique to the image data.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: thresholded image data.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        logging.info('Converting image dtype to float')\n    image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                        '{}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch,..., channel]\n\n            # Apply binary thresholding\n            threshold_img = (img > np.percentile(img, 50)) * 1\n\n            # Clip pixel values\n            if clip:\n                threshold_img = np.clip(threshold_img, a_min=np.percentile(threshold_img, 0.01), a_max=np.percentile(threshold_img, 99.9))\n\n            # Convert binary threshold image back to grayscale\n            threshold_img = np.dot(threshold_img, [0.2126, 0.7152, 0.0722])\n\n            threshold_img = np.clip(threshold_img, a_min=0, a_max=255)\n\n            image[batch,..., channel] = threshold_img\n    return image\n", "class_score": 0, "regress_score": 0}, {"code": "\ndef threshold_image(image, clip=False, threshold=0.05):\n    \"\"\"\n    Apply a threshold to the image data to detect spots.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n        threshold (float): Threshold value for thresholding.\n\n    Returns:\n        numpy.array: normalized image data with threshold applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        logging.info('Converting image dtype to float')\n    image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                        '{}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch,..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            thresholded_img = np.where(img > threshold, 255, 0)\n            thresholded_image = thresholded_img.astype('uint8')\n\n            image[batch,..., channel] = thresholded_image\n    return image\n", "class_score": 0, "regress_score": 0}, {"code": "\ndef median_blur(image, clip=False):\n    \"\"\"Apply a median blur to the image.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with median blur applied.\n    \"\"\"\n    from scipy.ndimage import median_filter as mf\n\n    if not np.issubdtype(image.dtype, np.floating):\n        logging.info('Converting image dtype to float')\n    image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                        '{}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch,..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            image[batch,..., channel] = mf(img, size=3)\n\n    return image\n", "class_score": 0, "regress_score": 0}, {"code": "\ndef median_blur(image, clip=False):\n    \"\"\"Apply a median blur to the image data.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with median blur applied.\n    \"\"\"\n    from scipy.ndimage import median_filter as mf\n\n    if not np.issubdtype(image.dtype, np.floating):\n        logging.info('Converting image dtype to float')\n    image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                        '{}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch,..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            image[batch,..., channel] = mf(img, size=3)\n\n    return image\n", "class_score": 0, "regress_score": 0}, {"code": "\nimport cv2\nimport numpy as np\n\ndef bilateral_filter(image, clip=False):\n    \"\"\"\n    Apply a bilateral filter to the image.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with bilateral filter applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        logging.info('Converting image dtype to float')\n    image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                        '{}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch,..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            bilateral_filtered_img = cv2.bilateralFilter(img.astype(np.uint8), 5, 50, 50)\n            image[batch,..., channel] = bilateral_filtered_img.astype('float32')\n\n    return image\n", "class_score": 0, "regress_score": 0}, {"code": "\ndef median_filter(image, clip=False):\n    \"\"\"\n    Apply a median filter to the image.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with median filter applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        logging.info('Converting image dtype to float')\n    image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                        '{}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch,..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            median_filtered_img = cv2.medianBlur(img.astype(np.uint8), 5)\n            image[batch,..., channel] = median_filtered_img.astype('float32')\n\n    return image\n", "class_score": 0, "regress_score": 0}]