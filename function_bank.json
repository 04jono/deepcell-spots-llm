[{"code": "\ndef median_blur(image, clip=False):\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            image[batch, ..., channel] = cv.medianBlur(img, ksize=5)\n\n    return image\n", "class_loss": 0.4258013582210047, "regress_loss": 0.5454990308176964}, {"code": "\ndef median_blur_corrected(image, clip=False):\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            img_uint8 = cv.normalize(img, None, 0, 255, cv.NORM_MINMAX).astype('uint8')\n            blurred = cv.medianBlur(img_uint8, ksize=7)\n            image[batch, ..., channel] = blurred.astype('float32') / 255.0\n\n    return image\n", "class_loss": 1.6059528826438683, "regress_loss": 0.9272335829569939}, {"code": "def laplacian_filter(image, clip=False):\n    \"\"\"Apply a Laplacian filter to highlight edges in the image.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n            \n            laplacian_img = cv.Laplacian(img, ddepth=cv.CV_32F)\n\n            image[batch, ..., channel] = laplacian_img\n\n    return image\n", "class_loss": 2.5736995307689017, "regress_loss": 2.0198133828792164}, {"code": "def bilateral_filter(image, clip=False):\n    \"\"\"Apply bilateral filtering to the image.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Determines if pixel values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with bilateral filter applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying bilateral filter\n            filtered_img = cv.bilateralFilter(img.astype('float32'), d=9, sigmaColor=75, sigmaSpace=75)\n            image[batch, ..., channel] = filtered_img\n\n    return image\n", "class_loss": 1.0921920349405325, "regress_loss": 0.9082981677765541}, {"code": "def modified_bilateral_filter(image, clip=False):\n    \"\"\"Apply modified bilateral filtering to the image.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying modified bilateral filter with updated sigmaColor and sigmaSpace\n            filtered_img = cv.bilateralFilter(img.astype('float32'), d=9, sigmaColor=50, sigmaSpace=50)\n            image[batch, ..., channel] = filtered_img\n\n    return image\n", "class_loss": 1.0913335999890053, "regress_loss": 0.9078747471596332}, {"code": "def morphological_operations(image, clip=False):\n    \"\"\"Apply morphological operations to the image to enhance spot detection.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel = cv.getStructuringElement(cv.MORPH_RECT, (5, 5))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying erosion followed by dilation\n            morphed_img = cv.erode(img, kernel, iterations=1)\n            morphed_img = cv.dilate(morphed_img, kernel, iterations=1)\n\n            image[batch, ..., channel] = morphed_img\n\n    return image\n", "class_loss": 1.944129659219625, "regress_loss": 1.1467517826785432}, {"code": "def custom_median_blur(image, clip=False):\n    \"\"\"Apply modified median blur to the image, adjusting kernel size.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Convert to uint8 to apply medianBlur\n            img_uint8 = cv.normalize(img, None, 0, 255, cv.NORM_MINMAX).astype('uint8')\n            blurred = cv.medianBlur(img_uint8, ksize=7)\n            \n            # Convert back to float32\n            image[batch, ..., channel] = blurred.astype('float32') / 255.0\n\n    return image\n", "class_loss": 1.2711633519811971, "regress_loss": 0.9157665736497717}, {"code": "def gaussian_blur(image, clip=False):\n    \"\"\"Apply Gaussian Blur to the image.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=0)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.026341761353405865, "regress_loss": 0.34366998662973974}, {"code": "def enhanced_gaussian_blur(image, clip=False):\n    \"\"\"Apply an enhanced Gaussian Blur to the image with an adjusted sigmaX.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with adjusted sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.023195506258065157, "regress_loss": 0.3372028724468769}, {"code": "def combined_transform(image, clip=False):\n    \"\"\"Apply a combination of morphological operations and filtering to the image.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, (5, 5))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Apply morphological opening to remove small objects\n            morphed_img = cv.morphologyEx(img, cv.MORPH_OPEN, kernel)\n\n            # Apply Gaussian blur\n            blurred_img = cv.GaussianBlur(morphed_img, (5, 5), sigmaX=0)\n\n            # Apply bilateral filter\n            filtered_img = cv.bilateralFilter(blurred_img.astype('float32'), d=9, sigmaColor=50, sigmaSpace=50)\n\n            image[batch, ..., channel] = filtered_img\n\n    return image\n", "class_loss": 2.762662325014776, "regress_loss": 1.1293542036350737}, {"code": "def modified_enhanced_gaussian_blur(image, clip=False):\n    \"\"\"Apply an enhanced Gaussian Blur to the image with an adjusted sigmaX.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with another adjusted sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=2)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.12494882733927683, "regress_loss": 0.43379790645013466}, {"code": "def modified_gaussian_blur(image, clip=False):\n    \"\"\"Apply a Gaussian Blur to the image with a further modified sigmaX.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with a further modified sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1.5)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.0692465261784085, "regress_loss": 0.3914206229308818}, {"code": "def laplacian_of_gaussian(image, clip=False):\n    \"\"\"Apply Laplacian of Gaussian (LoG) filtering to the image.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur to smooth the image\n            blurred = cv.GaussianBlur(img, (5, 5), sigmaX=1.5)\n            # Applying Laplacian to detect edges\n            log_img = cv.Laplacian(blurred, ddepth=cv.CV_32F)\n\n            image[batch, ..., channel] = log_img\n\n    return image\n", "class_loss": 3.6829038160912533, "regress_loss": 1.668011210066207}, {"code": "def modified_enhanced_gaussian_blur(image, clip=False):\n    \"\"\"Apply an enhanced Gaussian Blur to the image with an adjusted sigmaX.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with modified sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1.8)\n\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.10436875045180638, "regress_loss": 0.41892337727736917}, {"code": "def dilate_image(image, clip=False):\n    \"\"\"Apply dilation to enhance features in the image.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel = cv.getStructuringElement(cv.MORPH_RECT, (5, 5))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n                \n            # Applying dilation\n            dilated_img = cv.dilate(img, kernel, iterations=1)\n            image[batch, ..., channel] = dilated_img\n\n    return image\n", "class_loss": 0.1712891800140843, "regress_loss": 1.1211745003436475}, {"code": "def modified_enhanced_gaussian_blur_v2(image, clip=False):\n    \"\"\"Apply an enhanced Gaussian Blur to the image with an adjusted sigmaX to optimize spot detection.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with an increased sigmaX to enhance contrast and definition\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=2)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.12494882733927683, "regress_loss": 0.43379790645013466}, {"code": "def sobel_and_gaussian_blur(image, clip=False):\n    \"\"\"Apply Sobel edge detection followed by Gaussian Blur.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Applying Sobel edge detection\n            sobelx = cv.Sobel(img, cv.CV_64F, 1, 0, ksize=5)\n            sobely = cv.Sobel(img, cv.CV_64F, 0, 1, ksize=5)\n            sobel_combined = np.sqrt(sobelx**2 + sobely**2)\n\n            # Applying Gaussian Blur\n            blurred_img = cv.GaussianBlur(sobel_combined, (5, 5), sigmaX=1)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 1.708842009464477, "regress_loss": 0.8506499858612709}, {"code": "def sharpen_and_gaussian_blur(image, clip=False):\n    \"\"\"Apply sharpening followed by Gaussian Blur with adjusted sigmaX.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5,-1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with a different sigmaX value\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.2)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.016384486489225813, "regress_loss": 0.3030836675712403}, {"code": "def scharr_and_bilateral_filter(image, clip=False):\n    \"\"\"Apply Scharr edge detection followed by Bilateral Filter to preserve edges.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n    \n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply Scharr edge detection\n            scharrx = cv.Scharr(img, cv.CV_64F, 1, 0)\n            scharry = cv.Scharr(img, cv.CV_64F, 0, 1)\n            scharr_combined = np.sqrt(scharrx**2 + scharry**2).astype('float32')\n            \n            # Clip extremes if necessary\n            if clip:\n                scharr_combined = np.clip(scharr_combined, \n                                          a_min=np.percentile(scharr_combined, 0.01), \n                                          a_max=np.percentile(scharr_combined, 99.9))\n\n            # Apply Bilateral Filter for edge-preserving smoothing\n            filtered_img = cv.bilateralFilter(scharr_combined, d=9, sigmaColor=75, sigmaSpace=75)\n            image[batch, ..., channel] = filtered_img\n\n    return image\n", "class_loss": 0.12942105515840205, "regress_loss": 0.7136391797598373}, {"code": "def sharpen_and_gaussian_blur_v2(image, clip=False):\n    \"\"\"Apply sharpening followed by Gaussian Blur with further adjusted sigmaX.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with a further adjusted sigmaX value\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.5)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.017359107412011462, "regress_loss": 0.32183172696448387}, {"code": "def scharr_laplacian(image, clip=False):\n    \"\"\"Apply Scharr and Laplacian filtering to the image for edge enhancement.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply Scharr edge detection\n            scharr_x = cv.Scharr(img, cv.CV_64F, 1, 0)\n            scharr_y = cv.Scharr(img, cv.CV_64F, 0, 1)\n            scharr_combined = np.sqrt(scharr_x**2 + scharr_y**2).astype('float32')\n\n            # Optionally clip the extremes\n            if clip:\n                scharr_combined = np.clip(scharr_combined, \n                                          a_min=np.percentile(scharr_combined, 0.01), \n                                          a_max=np.percentile(scharr_combined, 99.9))\n\n            # Apply Laplacian filter for further edge enhancement\n            laplacian_filtered = cv.Laplacian(scharr_combined, ddepth=cv.CV_32F)\n            image[batch, ..., channel] = laplacian_filtered\n\n    return image\n", "class_loss": 2.900154492956527, "regress_loss": 1.6703999128113403}, {"code": "def modified_sharpen_and_gaussian_blur(image, clip=False):\n    \"\"\"Apply sharpening followed by Gaussian Blur with a modified sigmaX.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with a slightly adjusted sigmaX value\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.6)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.01930389515163892, "regress_loss": 0.3306853214001402}, {"code": "def sobel_and_gaussian(image, clip=False):\n    \"\"\"Apply Sobel edge detection followed by Gaussian Blur.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply Sobel edge detection\n            sobelx = cv.Sobel(img, cv.CV_64F, 1, 0, ksize=5)\n            sobely = cv.Sobel(img, cv.CV_64F, 0, 1, ksize=5)\n            sobel_combined = np.sqrt(sobelx**2 + sobely**2)\n\n            # Apply Gaussian Blur\n            blurred_img = cv.GaussianBlur(sobel_combined, (5, 5), sigmaX=1)\n\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 1.708842009464477, "regress_loss": 0.8506499858612709}, {"code": "def adjusted_sharpen_and_gaussian_blur(image, clip=False):\n    \"\"\"Apply sharpening followed by Gaussian Blur with an adjusted sigmaX.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with adjusted sigmaX\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.3)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.015724029096011866, "regress_loss": 0.30756734973414146}, {"code": "def scharr_then_bilateral(image, clip=False):\n    \"\"\"Apply Scharr edge detection followed by Bilateral Filter.\"\"\"\n\n    # Ensure image is float32\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    # Check image format\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply Scharr edge detection\n            scharr_x = cv.Scharr(img, cv.CV_32F, 1, 0)\n            scharr_y = cv.Scharr(img, cv.CV_32F, 0, 1)\n            scharr_combined = np.sqrt(scharr_x ** 2 + scharr_y ** 2)\n\n            # Clip extremes if necessary\n            if clip:\n                scharr_combined = np.clip(scharr_combined,\n                                          a_min=np.percentile(scharr_combined, 0.01),\n                                          a_max=np.percentile(scharr_combined, 99.9))\n\n            # Apply Bilateral Filter\n            filtered_img = cv.bilateralFilter(scharr_combined.astype('float32'), d=9, sigmaColor=75, sigmaSpace=75)\n            image[batch, ..., channel] = filtered_img\n\n    return image\n", "class_loss": 0.12942105660492437, "regress_loss": 0.7136391826132511}, {"code": "def sharpen_and_gaussian_blur_v3(image, clip=False):\n    \"\"\"Apply sharpening followed by Gaussian Blur with further adjusted sigmaX.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with a further adjusted sigmaX value\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.7)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.021895678329994863, "regress_loss": 0.3403766586425457}, {"code": "def enhance_and_blur(image, clip=False):\n    \"\"\"Enhance image details and then apply a custom blur.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharpen = np.array([[0, -1, 0], [-1, 10, -1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Enhance image details\n            enhanced_img = cv.filter2D(img, -1, kernel_sharpen)\n\n            if clip:\n                enhanced_img = np.clip(enhanced_img, a_min=np.percentile(enhanced_img, 0.1), \n                                       a_max=np.percentile(enhanced_img, 99.9))\n\n            # Apply Gaussian blur with a large sigmaX for unique smoothing\n            blurred_img = cv.GaussianBlur(enhanced_img, (5, 5), sigmaX=1.9)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.2770853888867621, "regress_loss": 0.3990984600275121}, {"code": "def modified_sharpen_and_gaussian_blur_v4(image, clip=False):\n    \"\"\"Apply sharpening followed by Gaussian Blur with a fine-tuned sigmaX.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n    \n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with a slightly varied sigmaX\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.3)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.015724029096011866, "regress_loss": 0.30756734973414146}, {"code": "def preprocess_image_new(image, clip=False):\n    \"\"\"Apply sharpening followed by a custom Gaussian Blur to the image.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5,-1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with adjusted sigmaX for optimal blurring\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.5)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.017359107412011462, "regress_loss": 0.32183172696448387}, {"code": "def enhanced_gaussian_blur_variant(image, clip=False):\n    \"\"\"Apply an enhanced Gaussian Blur with a slightly adjusted sigmaX.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with a modified sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1.2)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.03633713905768905, "regress_loss": 0.35884707872854904}, {"code": "def dilate_and_blur(image, clip=False):\n    \"\"\"Apply dilation followed by Gaussian Blur.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, (3, 3))\n    \n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Optionally clip image pixel extremes\n            if clip:\n                img = np.clip(img, \n                              a_min=np.percentile(img, 0.01), \n                              a_max=np.percentile(img, 99.9))\n\n            # Apply dilation\n            dilated_img = cv.dilate(img, kernel, iterations=1)\n\n            # Apply Gaussian Blur\n            blurred_img = cv.GaussianBlur(dilated_img, (5, 5), sigmaX=1.0)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.025401946387570748, "regress_loss": 0.3880993142089945}, {"code": "def enhanced_gaussian_blur_v2(image, clip=False):\n    \"\"\"Apply a Gaussian Blur to the image with a finely tuned sigmaX value.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with modified sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1.1)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.02870035638408537, "regress_loss": 0.34768921564868155}, {"code": "def box_and_erode_filter(image, clip=False):\n    \"\"\"Apply a combination of box filter and erosion on the image.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    kernel = cv.getStructuringElement(cv.MORPH_RECT, (3, 3))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            \n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying box filter\n            box_filtered_img = cv.boxFilter(img, ddepth=-1, ksize=(5, 5))\n            \n            # Applying erosion\n            eroded_img = cv.erode(box_filtered_img, kernel, iterations=1)\n\n            image[batch, ..., channel] = eroded_img\n\n    return image\n", "class_loss": 0.3016903116442065, "regress_loss": 0.5024448344682125}, {"code": "def adjusted_gaussian_blur(image, clip=False):\n    \"\"\"Apply Gaussian Blur with modified sigmaX.\"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with modified sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1.3)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.046046896490882686, "regress_loss": 0.37011454674474736}, {"code": "def scharr_and_blur(image, clip=False):\n    \"\"\"Apply Scharr filter followed by Gaussian Blur to the image.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Apply Scharr filter\n            scharr_x = cv.Scharr(img, cv.CV_32F, 1, 0)\n            scharr_y = cv.Scharr(img, cv.CV_32F, 0, 1)\n            scharr_combined = np.sqrt(scharr_x ** 2 + scharr_y ** 2)\n\n            # Applying Gaussian blur\n            blurred_img = cv.GaussianBlur(scharr_combined, (5, 5), sigmaX=1)\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.5277786002434949, "regress_loss": 0.6469292089026025}, {"code": "def enhanced_gaussian_blur_v3(image, clip=False):\n    \"\"\"Apply Gaussian Blur with a slightly modified sigmaX for better spot detection.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with a further adjusted sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1.3)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.046046896490882686, "regress_loss": 0.37011454674474736}, {"code": "def scharr_bilateral_filter(image, clip=False):\n    \"\"\"\n    Apply Scharr edge detection followed by Bilateral Filter to the image.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Determines if pixel values are clipped by percentile.\n\n    Returns:\n        numpy.array: Image data with Scharr and Bilateral filter applied.\n    \"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Apply Scharr edge detection\n            scharr_x = cv.Scharr(img, cv.CV_32F, 1, 0)\n            scharr_y = cv.Scharr(img, cv.CV_32F, 0, 1)\n            scharr_combined = np.sqrt(scharr_x ** 2 + scharr_y ** 2)\n\n            # Apply Bilateral Filter for edge-preserving smoothing\n            filtered_img = cv.bilateralFilter(scharr_combined.astype('float32'), d=9, sigmaColor=75, sigmaSpace=75)\n            \n            image[batch, ..., channel] = filtered_img\n\n    return image\n", "class_loss": 0.12443768134974736, "regress_loss": 0.6883321518593646}, {"code": "def enhanced_gaussian_blur_variant(image, clip=False):\n    \"\"\"Apply an enhanced Gaussian Blur with a slightly adjusted sigmaX.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Applying Gaussian blur with a modified sigmaX\n            blurred_img = cv.GaussianBlur(img, (5, 5), sigmaX=1.2)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.03633713905768905, "regress_loss": 0.35884707872854904}, {"code": "def contrast_bilateral_filter(image, clip=False):\n    \"\"\"Apply contrast stretch followed by a bilateral filter for preserving edges.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            \n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Contrast Stretch\n            min_val, max_val = np.min(img), np.max(img)\n            norm_img = (img - min_val) / (max_val - min_val)\n\n            # Applying Bilateral Filter\n            filtered_img = cv.bilateralFilter(norm_img, d=9, sigmaColor=75, sigmaSpace=75)\n            \n            image[batch, ..., channel] = filtered_img\n\n    return image\n", "class_loss": 0.8801022077677771, "regress_loss": 0.9312391284298389}, {"code": "def new_preprocessing_function(image, clip=False):\n    \"\"\"Apply median blur, edge detection, and histogram equalization to the image.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply median blur\n            blurred_img = cv.medianBlur(img.astype('float32'), ksize=5)\n            \n            # Edge detection using Canny\n            edges = cv.Canny((blurred_img * 255).astype('uint8'), 100, 200)\n\n            # Apply histogram equalization\n            if clip:\n                edges = np.clip(edges, a_min=np.percentile(edges, 0.01), a_max=np.percentile(edges, 99.9))\n            \n            eq_img = cv.equalizeHist(edges.astype('uint8')).astype('float32') / 255\n\n            image[batch, ..., channel] = eq_img\n\n    return image\n", "class_loss": 3.777285703953276, "regress_loss": 1.3893074139635613}, {"code": "def modified_sharpen_and_gaussian_blur(image, clip=False):\n    \"\"\"Apply sharpening followed by Gaussian Blur with a fine-tuned sigmaX.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n    \n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.4)\n            \n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.016112487900635585, "regress_loss": 0.31398937225024753}, {"code": "def bilateral_sharpen_gaussian_blur(image, clip=False):\n    \"\"\"Apply Bilateral Filter, sharpening, and Gaussian Blur to the image.\"\"\"\n    \n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n            \n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Apply bilateral filter\n            filtered_img = cv.bilateralFilter(img, d=9, sigmaColor=75, sigmaSpace=75)\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(filtered_img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.3)\n\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.9888672307331828, "regress_loss": 0.861748198879526}, {"code": "def optimize_sharpen_and_blur(image, clip=False):\n    \"\"\"Enhance image details using sharpening followed by optimized Gaussian Blur.\"\"\"\n\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}'.format(np.shape(image)))\n\n    kernel_sharp = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            # Apply optional clipping\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            # Apply sharpening\n            sharpened_img = cv.filter2D(img, -1, kernel_sharp)\n\n            # Applying Gaussian Blur with fine-tuned sigmaX value\n            blurred_img = cv.GaussianBlur(sharpened_img, (5, 5), sigmaX=1.8)\n\n            image[batch, ..., channel] = blurred_img\n\n    return image\n", "class_loss": 0.027610850852339507, "regress_loss": 0.3619967785445934}]