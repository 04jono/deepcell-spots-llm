[{"code": "\nimport cv2\nimport numpy as np\nimport logging\n\ndef bilateral_filter_transform(image, clip=False):\n    \"\"\"Apply a bilateral filter to the image.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with bilateral filter applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        logging.info('Converting image dtype to float')\n    image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was'\n                         ' {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            image[batch, ..., channel] = cv2.bilateralFilter(img, d=9, sigmaColor=75, sigmaSpace=75)\n\n    return image\n", "class_loss": 1.0921920349405325, "regress_loss": 0.9082981677765541}, {"code": "def gaussian_blur_transform(image, clip=False):\n    \"\"\"Apply a Gaussian blur to the image.\n    \n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with Gaussian blur applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            image[batch, ..., channel] = cv.GaussianBlur(img, (5, 5), 0)\n\n    return image\n", "class_loss": 0.026341761353405865, "regress_loss": 0.34366998662973974}, {"code": "def median_blur_transform(image, clip=False):\n    \"\"\"Apply a median blur to the image.\n    \n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with median blur applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            image[batch, ..., channel] = cv.medianBlur(img, 5)\n\n    return image\n", "class_loss": 0.42587268203150164, "regress_loss": 0.546105118587296}, {"code": "def gaussian_blur_transform(image, clip=False):\n    \"\"\"Apply a Gaussian blur to the image.\n    \n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with Gaussian blur applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            image[batch, ..., channel] = cv.GaussianBlur(img, (5, 5), 0)\n\n    return image\n", "class_loss": 0.026341761353405865, "regress_loss": 0.34366998662973974}, {"code": "def bilateral_filter_transform(image, clip=False):\n    \"\"\"Apply a bilateral filter to the image.\n\n    Args:\n        image (numpy.array): 4D numpy array of image data.\n        clip (boolean): Defaults to false. Determines if pixel\n            values are clipped by percentile.\n\n    Returns:\n        numpy.array: image data with bilateral filter applied.\n    \"\"\"\n    if not np.issubdtype(image.dtype, np.floating):\n        image = image.astype('float32')\n\n    if not len(np.shape(image)) == 4:\n        raise ValueError('Image must be 4D, input image shape was {}.'.format(np.shape(image)))\n\n    for batch in range(image.shape[0]):\n        for channel in range(image.shape[-1]):\n            img = image[batch, ..., channel]\n\n            if clip:\n                img = np.clip(img, a_min=np.percentile(img, 0.01), a_max=np.percentile(img, 99.9))\n\n            image[batch, ..., channel] = cv.bilateralFilter(img, d=9, sigmaColor=75, sigmaSpace=75)\n\n    return image\n", "class_loss": 1.0921920349405325, "regress_loss": 0.9082981677765541}]